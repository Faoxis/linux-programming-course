### Первая неделя обучения
<hr>

#### Необходимые пакеты:

```sh
sudo apt-get install build-essential
```

#### Порядок действий для создания разделяемых библиотек (порядок для понимания - от простого к сложному):
1. Создаем программу `Hello World`
	* Создадим простой файл [main.c](../week1/step1/main.c).
	* Скомпилируем программу в простой исполняемый файлс с помощью компилятора `gcc` (флаг `-o` говорит о имени исполняемого файла): `gcc -o hello main.c`.
	* Можно запускать скомпилированный файл: `./hello`.
2. Выведем сообщение на печать в отдельный файл, но со сборкой монолитного исполняемого модуля.
	* Создадим файл [hello.c](../week1/step2/hello.c).
	* Создадим файл [hello.h](../week1/step2/hello.h).
	* Создадим файл [main.c](../week1/step2/main.c).
	* Скомпилируем `c-файлы` в объектный код (по умолчанию `gcc` пытает создать исполняемый файл, для того, чтобы выполнить только этап компиляции используется флаг `-c`): `gcc -o hello.o -c hello.c`.
	* Повторим процесс для `main.c`: `gcc -o main.o -c main.c`.
	* В результате получилось два объектных файла ('main.o' и 'hello.o'). Для их линковки необходимо выполнить команду: `gcc -o hello hello.o main.o`.
	* В результате получился исполняемый файл `hello`.
3. Вынесим код в отдельную библиотеку и научимся ее линковать.
    * Для создания динамической библиотеки необходимо выполнить команду  (флаг `-shared` говорит о создании разделяемой библиотеки, `-fPIC` флаг говорит о независимости от разрядности процесса): `gcc -o libHello.so -shared -fPIC hello.c`.
    * Для просмотра испорта и экспорта имен в библиотеке можно воспользоваться командой `nm libHello.so`.
    * Для компиляции программы с использованием динамической библиотеки можно использовать: `gcc main.c -L. -lHello -o hello`, где:
        * `-L` указывает путь библиотеки. `-L.` - текущая директория.
        * `-l` - имя библиотеки, с которой хотим слинковаться без префикса `lib` и постфикса `.so`.
    * В некоторых системах необходимо настроить системный сервис динамической линковки `LD`. Сделать это можно двумя способами:
        * Положить библиотеку в специальную директорию, от куда `LD` ее подтянет.
        * Задать `LD` путь к библиотеке через переменные окружения:
            * `LD_LIBRARY_PATH` - пути к библиотекам, которые будут загружены в случае, если не найдены в основных директориях `LD`.
            * `LD_PRELOAD` - пути к библиотекам, которые будут загружена до своих основных директорий с библиотеками. Здесь можно подменить стандартные библиотеки своими.
            * Пример подключения: `export LD_LIBRARY_PATH=.`
4. Работа с компилятором `C++` отличается от работы с компилятором `C`. 
    * Переименуем файл `hello.c` в [hello.cpp](../week1/step3/hello.cpp).
    * Попробуем выполнить команду `gcc -shared -o libHello.so -fPIC hello.cpp` и выполнить `gcc -o hello main.c -L. -lHello -o hello`. Получим ошибку на обращение к несуществующему символу `hello_message`.
    * Если посмотреть на экспортируемые имена (`nm libHello.so`), то можно увидеть имя `_Z13hello_messagePKc` вместо `hello_message`.
    * Чтобы посмотреть изначальное название функции, можно воспользоваться `linux`-утилитой `c++filt`: `c++filt _Z13hello_messagePKc`.
    * Для того, чтобы скомпилировать в `C` можно в заголовочном файле указать `extern "C"`: [hello.h](../week1/step3/hello.h).
    * После этого команда `gcc -o hello main.cpp -L. -lHello -o hello` успешно выполняется.


#### Инструмент автоматизированной сборки `GNU make`.
1. Пример типичного `Makefile`: [Makefile](../week1/step4/Makefile).

#### Динамическая линковка в `Runtime`.
1. Типичная схема подгрузки функции `void hello_message(const char *name)` из объектного файла `libHello.so` в `Runtime`:
    * Меняем файл [`main.c`](../week1/step5/main.c) нужным образом.
    * Меняем [`Makefile`](../week1/step5/Makefile). При сборке убираем в нем подключение объектного файла и добавляем флайг `-ldl` для подключения функции `dlopen`.
    * Пересобираем и запускаем.



[Назад к оглавлению](../README.md)